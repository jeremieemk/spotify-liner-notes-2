'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var crossFetch = require('cross-fetch');
var OAuth = require('oauth-1.0a');
var querystring = require('querystring');
var Bottleneck = require('bottleneck');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var crossFetch__default = /*#__PURE__*/_interopDefaultLegacy(crossFetch);
var OAuth__default = /*#__PURE__*/_interopDefaultLegacy(OAuth);
var Bottleneck__default = /*#__PURE__*/_interopDefaultLegacy(Bottleneck);

(function (DataQualityEnum) {
    DataQualityEnum["NEEDS_VOTE"] = "Needs Vote";
    DataQualityEnum["NEEDS_MINOR_CHANGE"] = "Needs Minor Changes";
    DataQualityEnum["CORRECT"] = "Correct";
})(exports.DataQualityEnum || (exports.DataQualityEnum = {}));
(function (CommunityStatusesEnum) {
    CommunityStatusesEnum["ACCEPTED"] = "Accepted";
})(exports.CommunityStatusesEnum || (exports.CommunityStatusesEnum = {}));

(function (ReleaseConditionsEnum) {
    ReleaseConditionsEnum["MINT"] = "Mint (M)";
    ReleaseConditionsEnum["NEAR_MINT"] = "Near Mint (NM or M-)";
    ReleaseConditionsEnum["VERY_GOOD_PLUS"] = "Very Good Plus (VG+)";
    ReleaseConditionsEnum["VERY_GOOD"] = "Very Good (VG)";
    ReleaseConditionsEnum["GOOD_PLUS"] = "Good Plus (G+)";
    ReleaseConditionsEnum["GOOD"] = "Good (G)";
    ReleaseConditionsEnum["FAIR"] = "Fair (F)";
    ReleaseConditionsEnum["POOR"] = "Poor (P)";
})(exports.ReleaseConditionsEnum || (exports.ReleaseConditionsEnum = {}));
(function (SleeveConditionsEnum) {
    SleeveConditionsEnum["MINT"] = "Mint (M)";
    SleeveConditionsEnum["NEAR_MINT"] = "Near Mint (NM or M-)";
    SleeveConditionsEnum["VERY_GOOD_PLUS"] = "Very Good Plus (VG+)";
    SleeveConditionsEnum["VERY_GOOD"] = "Very Good (VG)";
    SleeveConditionsEnum["GOOD_PLUS"] = "Good Plus (G+)";
    SleeveConditionsEnum["GOOD"] = "Good (G)";
    SleeveConditionsEnum["FAIR"] = "Fair (F)";
    SleeveConditionsEnum["POOR"] = "Poor (P)";
    SleeveConditionsEnum["GENERIC"] = "Generic";
    SleeveConditionsEnum["NOT_GRADED"] = "Not Graded";
    SleeveConditionsEnum["NO_COVER"] = "No Cover";
})(exports.SleeveConditionsEnum || (exports.SleeveConditionsEnum = {}));

(function (CurrenciesEnum) {
    CurrenciesEnum["USD"] = "USD";
    CurrenciesEnum["GBP"] = "GBP";
    CurrenciesEnum["EUR"] = "EUR";
    CurrenciesEnum["CAD"] = "CAD";
    CurrenciesEnum["AUD"] = "AUD";
    CurrenciesEnum["JPY"] = "JPY";
    CurrenciesEnum["CHF"] = "CHF";
    CurrenciesEnum["MXN"] = "MXN";
    CurrenciesEnum["BRL"] = "BRL";
    CurrenciesEnum["NZD"] = "NZD";
    CurrenciesEnum["SEK"] = "SEK";
    CurrenciesEnum["ZAR"] = "ZAR";
})(exports.CurrenciesEnum || (exports.CurrenciesEnum = {}));

(function (FolderIdsEnum) {
    FolderIdsEnum[FolderIdsEnum["ALL"] = 0] = "ALL";
    FolderIdsEnum[FolderIdsEnum["UNCATEGORIZED"] = 1] = "UNCATEGORIZED";
})(exports.FolderIdsEnum || (exports.FolderIdsEnum = {}));

(function (InventoryStatusesEnum) {
    InventoryStatusesEnum["ALL"] = "All";
    InventoryStatusesEnum["DELETED"] = "Deleted";
    InventoryStatusesEnum["DRAFT"] = "Draft";
    InventoryStatusesEnum["EXPIRED"] = "Expired";
    InventoryStatusesEnum["FOR_SALE"] = "For Sale";
    InventoryStatusesEnum["SOLD"] = "Sold";
    InventoryStatusesEnum["SUSPENDED"] = "Suspended";
    InventoryStatusesEnum["VIOLATION"] = "Violation";
})(exports.InventoryStatusesEnum || (exports.InventoryStatusesEnum = {}));
(function (InventorySortEnum) {
    InventorySortEnum["LISTED"] = "listed";
    InventorySortEnum["PRICE"] = "price";
    InventorySortEnum["ITEM"] = "item";
    InventorySortEnum["ARTIST"] = "artist";
    InventorySortEnum["LABEL"] = "label";
    InventorySortEnum["CATNO"] = "catno";
    InventorySortEnum["AUDIO"] = "audio";
    InventorySortEnum["STATUS"] = "status";
    InventorySortEnum["LOCATION"] = "location";
})(exports.InventorySortEnum || (exports.InventorySortEnum = {}));

(function (ListingStatusesEnum) {
    ListingStatusesEnum["FOR_SALE"] = "For Sale";
    ListingStatusesEnum["DRAFT"] = "Draft";
})(exports.ListingStatusesEnum || (exports.ListingStatusesEnum = {}));

(function (EditOrderStatusesEnum) {
    EditOrderStatusesEnum["NEW_ORDER"] = "New Order";
    EditOrderStatusesEnum["BUYER_CONTACTER"] = "Buyer Contacted";
    EditOrderStatusesEnum["INVOICE_SENT"] = "Invoice Sent";
    EditOrderStatusesEnum["PAYMENT_PENDING"] = "Payment Pending";
    EditOrderStatusesEnum["PAYMENT_RECEIVED"] = "Payment Received";
    EditOrderStatusesEnum["SHIPPED"] = "Shipped";
    EditOrderStatusesEnum["REFUND_SENT"] = "Refund Sent";
    EditOrderStatusesEnum["CANCELLED_NON_PAYING_BUYER"] = "Cancelled (Non-Paying Buyer)";
    EditOrderStatusesEnum["CANCELLED_ITEM_UNAVAILABLE"] = "Cancelled (Item Unavailable)";
    EditOrderStatusesEnum["CANCELLED_PER_BUYER_REQUEST"] = "Cancelled (Per Buyer's Request)";
})(exports.EditOrderStatusesEnum || (exports.EditOrderStatusesEnum = {}));
(function (OrderStatusesEnum) {
    OrderStatusesEnum["ALL"] = "All";
    OrderStatusesEnum["NEW_ORDER"] = "New Order";
    OrderStatusesEnum["BUYER_CONTACTED"] = "Buyer Contacted";
    OrderStatusesEnum["INVOICE_SENT"] = "Invoice Sent";
    OrderStatusesEnum["PAYMENT_PENDING"] = "Payment Pending";
    OrderStatusesEnum["PAYMENT_RECEIVED"] = "Payment Received";
    OrderStatusesEnum["SHIPPED"] = "Shipped";
    OrderStatusesEnum["MERGED"] = "Merged";
    OrderStatusesEnum["ORDER_CHANGED"] = "Order Changed";
    OrderStatusesEnum["REFUND_SENT"] = "Refund Sent";
    OrderStatusesEnum["CANCELLED"] = "Cancelled";
    OrderStatusesEnum["CANCELLED_NON_PAYING_BUYER"] = "Cancelled (Non-Paying Buyer)";
    OrderStatusesEnum["CANCELLED_ITEM_UNAVAILABLE"] = "Cancelled (Item Unavailable)";
    OrderStatusesEnum["CANCELLED_PER_BUYER_REQUEST"] = "Cancelled (Per Buyer's Request)";
    OrderStatusesEnum["CANCELLED_REFUND_RECEIVED"] = "Cancelled (Refund Received)";
})(exports.OrderStatusesEnum || (exports.OrderStatusesEnum = {}));
(function (OrderSortEnum) {
    OrderSortEnum["ID"] = "id";
    OrderSortEnum["BUYER"] = "buyer";
    OrderSortEnum["CREATED"] = "created";
    OrderSortEnum["STATUS"] = "status";
    OrderSortEnum["LAST_ACTIVITY"] = "last_activity";
})(exports.OrderSortEnum || (exports.OrderSortEnum = {}));
(function (OrderMessageTypesEnum) {
    OrderMessageTypesEnum["STATUS"] = "status";
    OrderMessageTypesEnum["MESSAGE"] = "message";
    OrderMessageTypesEnum["SHIPPING"] = "shipping";
    OrderMessageTypesEnum["REFUND_SENT"] = "refund_sent";
    OrderMessageTypesEnum["REFUND_RECEIVED"] = "refund_received";
})(exports.OrderMessageTypesEnum || (exports.OrderMessageTypesEnum = {}));

(function (ReleaseSortEnum) {
    ReleaseSortEnum["YEAR"] = "year";
    ReleaseSortEnum["TITLE"] = "title";
    ReleaseSortEnum["FORMAT"] = "format";
})(exports.ReleaseSortEnum || (exports.ReleaseSortEnum = {}));

(function (SearchTypeEnum) {
    SearchTypeEnum["RELEASE"] = "release";
    SearchTypeEnum["MASTER"] = "master";
    SearchTypeEnum["ARTIST"] = "artist";
    SearchTypeEnum["LABEL"] = "label";
})(exports.SearchTypeEnum || (exports.SearchTypeEnum = {}));

(function (UserSortEnum) {
    UserSortEnum["LABEL"] = "label";
    UserSortEnum["ARTIST"] = "artist";
    UserSortEnum["TITLE"] = "title";
    UserSortEnum["CATNO"] = "catno";
    UserSortEnum["FORMAT"] = "format";
    UserSortEnum["RATING"] = "rating";
    UserSortEnum["YEAR"] = "year";
    UserSortEnum["ADDED"] = "added";
})(exports.UserSortEnum || (exports.UserSortEnum = {}));

class AuthError extends Error {
    constructor() {
        super();
        this.name = 'AuthError';
        this.message = 'Unauthorized';
        this.statusCode = 401;
        Object.setPrototypeOf(this, AuthError.prototype);
    }
}

class DiscogsError extends Error {
    constructor(message, code) {
        super(message);
        this.message = message;
        this.name = 'DiscogsError';
        this.statusCode = code;
        Object.setPrototypeOf(this, DiscogsError.prototype);
    }
}

/**
 * HTTP verbs.
 *
 * @internal
 */
var HTTPVerbsEnum;
(function (HTTPVerbsEnum) {
    HTTPVerbsEnum["GET"] = "GET";
    HTTPVerbsEnum["POST"] = "POST";
    HTTPVerbsEnum["PUT"] = "PUT";
    HTTPVerbsEnum["DELETE"] = "DELETE";
})(HTTPVerbsEnum || (HTTPVerbsEnum = {}));
/**
 * Fetch helper.
 *
 * @param url - URL to fetch
 * @param options - Fetch options
 * @returns
 * @throws
 *
 * @internal
 */
async function fetch(url, options, shouldReturnBlob) {
    const response = await crossFetch__default['default'](url, options);
    // Check status
    const { status, statusText } = response;
    if (status === 401)
        throw new AuthError();
    if (status < 200 || status >= 300)
        throw new DiscogsError(statusText, status);
    if (status === 204)
        return Promise.resolve({});
    if (shouldReturnBlob) {
        const blob = await response.blob();
        return blob;
    }
    const data = await response.json();
    return data;
}
/**
 * Helper to add query to a URI. Strips undefined values.
 *
 * @param uri - Endpoint to which query will be appended.
 * @param query
 * @returns URI + query
 *
 * @internal
 */
function addQueryToUri(uri, query) {
    const definedKeys = Object.entries(query).reduce((acc, [key, value]) => {
        if (typeof value === 'undefined')
            return acc;
        return {
            ...acc,
            [key]: value,
        };
    }, {});
    return `${uri}?${querystring.stringify(definedKeys)}`;
}
/**
 * Helper to transform camelcased data keys to snakecased one and rename `currency` to `curr_abbr`.
 *
 * @param data
 * @returns Tranformed `data` object.
 *
 * @internal
 */
function transformData(data) {
    return Object.entries(data).reduce((acc, [key, value]) => ({
        ...acc,
        [key === 'currency' ? 'curr_abbr' : key.replace(/[A-Z]/g, (letter) => `_${letter.toLowerCase()}`)]: value,
    }), {});
}

/**
 * Helper to create a new instance of Bottleneck.
 *
 * @internal
 */
function createLimiter({ concurrency = 1, maxRequests, requestLimitInterval }) {
    return new Bottleneck__default['default']({
        maxConcurrent: concurrency,
        minTime: requestLimitInterval / maxRequests,
        reservoir: maxRequests,
        reservoirRefreshAmount: maxRequests,
        reservoirRefreshInterval: requestLimitInterval,
    });
}

const DEFAULT_PAGE = 1;
const DEFAULT_PER_PAGE = 50;
/**
 * Paginate helper.
 *
 * @internal
 */
function paginate(options) {
    const { page = DEFAULT_PAGE, perPage = DEFAULT_PER_PAGE } = options || {};
    return {
        // Minimum page is 1
        page: Math.max(DEFAULT_PAGE, page),
        // Maximum items per page are 100
        per_page: perPage <= 0 || perPage > 100 ? DEFAULT_PER_PAGE : perPage,
    };
}

(function (SortOrdersEnum) {
    SortOrdersEnum["ASC"] = "asc";
    SortOrdersEnum["DESC"] = "desc";
})(exports.SortOrdersEnum || (exports.SortOrdersEnum = {}));
/**
 * Sort by helper.
 *
 * @internal
 */
function sortBy(defaultSortBy, options) {
    const { by = defaultSortBy, order = exports.SortOrdersEnum.ASC } = options || {};
    return {
        sort: by,
        sort_order: order,
    };
}

/**
 * Base API URL to which URI will be appended.
 *
 * @internal
 */
const API_BASE_URL = 'https://api.discogs.com';
/**
 * Base URL dedicated to Discogs images.
 *
 * @internal
 */
const IMG_BASE_URL = 'https://img.discogs.com';
/**
 * Discogs API version.
 *
 * @internal
 */
const API_VERSION = 'v2';
/**
 * Default user-agent to be used in requests.
 *
 * @internal
 */
const DEFAULT_USER_AGENT = `Discojs/1.3.2`;
/**
 * Available output formats.
 *
 * @todo Edit types depending on chosen output format.
 */
var OutputFormatsEnum;
(function (OutputFormatsEnum) {
    OutputFormatsEnum["DISCOGS"] = "discogs";
    // PLAIN = 'plaintext',
    // HTML = 'html',
})(OutputFormatsEnum || (OutputFormatsEnum = {}));
/**
 * Type guard to check if authenticated thanks to user token.
 *
 * @internal
 */
function isAuthenticatedWithToken(options) {
    return Boolean(options) && typeof options.userToken === 'string';
}
/**
 * Type guard to check if authenticated thanks to consumer key.
 *
 * @internal
 */
function isAuthenticatedWithConsumerKey(options) {
    return (Boolean(options) &&
        typeof options.consumerKey === 'string' &&
        typeof options.consumerSecret === 'string' &&
        typeof options.oAuthToken === 'string' &&
        typeof options.oAuthTokenSecret === 'string');
}
/**
 * Type guard to check whether requests are authenticated or not.
 *
 * @internal
 */
function isAuthenticated(options) {
    return isAuthenticatedWithToken(options) || isAuthenticatedWithConsumerKey(options);
}
/**
 * Discojs.
 */
class Discojs {
    constructor(options) {
        const { userAgent = DEFAULT_USER_AGENT, outputFormat = OutputFormatsEnum.DISCOGS, requestLimit = 25, requestLimitAuth = 60, requestLimitInterval = 60 * 1000, fetchOptions = {}, } = options || {};
        this.userAgent = userAgent;
        this.outputFormat = outputFormat;
        this.limiter = createLimiter({
            maxRequests: isAuthenticated(options) ? requestLimitAuth : requestLimit,
            requestLimitInterval,
        });
        this.fetchOptions = fetchOptions;
        this.fetchHeaders = new crossFetch.Headers({
            Accept: `application/vnd.discogs.${API_VERSION}.${this.outputFormat}+json`,
            'Accept-Encoding': 'gzip,deflate',
            Connection: 'close',
            'Content-Type': 'application/json',
            'User-Agent': this.userAgent,
        });
        if (isAuthenticatedWithToken(options))
            this.setAuthorizationHeader = () => `Discogs token=${options.userToken}`;
        if (isAuthenticatedWithConsumerKey(options)) {
            const oAuth = new OAuth__default['default']({
                consumer: { key: options.consumerKey, secret: options.consumerSecret },
                signature_method: 'PLAINTEXT',
                version: '1.0',
            });
            this.setAuthorizationHeader = (url, method) => {
                if (!url || !method)
                    return '';
                const authObject = oAuth.authorize({ url, method }, { key: options.oAuthToken, secret: options.oAuthTokenSecret });
                return oAuth.toHeader(authObject).Authorization;
            };
        }
    }
    /**
     * Return currencies supported by Discogs.
     *
     * @category Helpers
     *
     * @static
     */
    static getSupportedCurrencies() {
        return Object.values(exports.CurrenciesEnum);
    }
    /**
     * Return release conditions supported by Discogs.
     *
     * @category Helpers
     *
     * @static
     */
    static getReleaseConditions() {
        return Object.values(exports.ReleaseConditionsEnum);
    }
    /**
     * Return slevve conditions supported by Discogs.
     *
     * @category Helpers
     *
     * @static
     */
    static getSleeveConditions() {
        return Object.values(exports.SleeveConditionsEnum);
    }
    /**
     * Private method used within other methods.
     *
     * @private
     * @internal
     */
    async fetch(uri, query, method, data) {
        const isImgEndpoint = uri.startsWith(IMG_BASE_URL);
        const endpoint = isImgEndpoint
            ? uri
            : API_BASE_URL + (query && typeof query === 'object' ? addQueryToUri(uri, query) : uri);
        const options = {
            ...this.fetchOptions,
            method: method || HTTPVerbsEnum.GET,
        };
        // Set Authorization header.
        if (this.setAuthorizationHeader)
            this.fetchHeaders.set('Authorization', this.setAuthorizationHeader(uri, method || HTTPVerbsEnum.GET));
        const clonedHeaders = new Map(this.fetchHeaders);
        if (data) {
            const stringifiedData = JSON.stringify(transformData(data));
            options.body = stringifiedData;
            clonedHeaders.set('Content-Type', 'application/json');
            clonedHeaders.set('Content-Length', Buffer.byteLength(stringifiedData, 'utf8').toString());
        }
        options.headers = Object.fromEntries(clonedHeaders);
        return this.limiter.schedule(() => fetch(endpoint, options, isImgEndpoint));
    }
    /**
     * Retrieve basic information about the authenticated user.
     *
     * @remarks
     * You can use this resource to find out who you’re authenticated as, and it also doubles as a good sanity check to ensure that you’re using OAuth correctly.
     *
     * @category User Identity
     *
     * @link https://www.discogs.com/developers#page:user-identity,header:user-identity-identity
     */
    async getIdentity() {
        return this.fetch('/oauth/identity');
    }
    /**
     * Retrieve authenticated user's username.
     *
     * @remarks
     * Used internally within methods that use `username` as a param.
     *
     * @category User Identity
     *
     * @private
     */
    async getUsername() {
        const { username } = await this.getIdentity();
        return username;
    }
    /**
     * Retrieve user's profile by username.
     *
     * @remarks
     * If authenticated as the requested user, the `email` key will be visible, and the `num_list count` will include the user’s private lists.
     * If authenticated as the requested user or the user’s collection/wantlist is public, the `num_collection` / `num_wantlist` keys will be visible.
     *
     * @category User Profile
     *
     * @link https://www.discogs.com/developers#page:user-identity,header:user-identity-profile
     */
    async getProfileForUser(username) {
        return this.fetch(`/users/${username}`);
    }
    /**
     * Retrieve authenticated user's profile.
     *
     * @category User Profile
     *
     * @link https://www.discogs.com/developers#page:user-identity,header:user-identity-profile
     */
    async getProfile() {
        const username = await this.getUsername();
        return this.getProfileForUser(username);
    }
    /**
     * Edit a user’s profile data.
     *
     * @category User Profile
     *
     * @link https://www.discogs.com/developers#page:user-identity,header:user-identity-profile
     */
    async editProfile(options) {
        const username = await this.getUsername();
        return this.fetch(`/users/${username}`, {}, HTTPVerbsEnum.POST, { username, ...options });
    }
    /**
     * Retrieve a user’s submissions by username.
     *
     * @category User Submissions
     *
     * @link https://www.discogs.com/developers#page:user-identity,header:user-identity-user-submissions
     */
    async getSubmissionsForUser(username, pagination) {
        return this.fetch(`/users/${username}/submissions`, paginate(pagination));
    }
    /**
     * Retrieve authenticated user’s submissions.
     *
     * @category User Submissions
     *
     * @link https://www.discogs.com/developers#page:user-identity,header:user-identity-user-submissions
     */
    async getSubmissions(pagination) {
        const username = await this.getUsername();
        return this.getSubmissionsForUser(username, pagination);
    }
    /**
     * Retrieve a user’s contributions by username.
     *
     * @category User Contributions
     *
     * @link https://www.discogs.com/developers#page:user-identity,header:user-identity-user-contributions
     */
    async getContributionsForUser(username, sort, pagination) {
        return this.fetch(`/users/${username}/contributions`, {
            ...sortBy(exports.UserSortEnum.ADDED, sort),
            ...paginate(pagination),
        });
    }
    /**
     * Retrieve authenticated user’s contributions.
     *
     * @category User Contributions
     *
     * @link https://www.discogs.com/developers#page:user-identity,header:user-identity-user-contributions
     */
    async getContributions(sort, pagination) {
        const username = await this.getUsername();
        return this.getContributionsForUser(username, sort, pagination);
    }
    /**
     * Retrieve a list of folders in a user’s collection.
     *
     * @remarks
     * If the collection has been made private by its owner, authentication as the collection owner is required.
     * If you are not authenticated as the collection owner, only folder ID 0 (the “All” folder) will be visible (if the requested user’s collection is public).
     *
     * @category User Collection
     *
     * @link https://www.discogs.com/developers#page:user-collection,header:user-collection-collection
     */
    async listFoldersForUser(username) {
        return this.fetch(`/users/${username}/collection/folders`);
    }
    /**
     * Retrieve a list of folders in authenticated user’s collection.
     *
     * @category User Collection
     *
     * @link https://www.discogs.com/developers#page:user-collection,header:user-collection-collection
     */
    async listFolders() {
        const username = await this.getUsername();
        return this.listFoldersForUser(username);
    }
    /**
     * Create a new folder in authenticated user’s collection.
     *
     * @category User Collection
     *
     * @link https://www.discogs.com/developers#page:user-collection,header:user-collection-collection
     */
    async createFolder(name) {
        const username = await this.getUsername();
        return this.fetch(`/users/${username}/collection/folders`, {}, HTTPVerbsEnum.POST, { name });
    }
    /**
     * Retrieve metadata about a folder in a user’s collection.
     *
     * @remarks
     * If folder_id is not 0, authentication as the collection owner is required.
     *
     * @category User Folder
     *
     * @link https://www.discogs.com/developers#page:user-collection,header:user-collection-collection-folder
     */
    async getFolderForUser(username, folderId) {
        return this.fetch(`/users/${username}/collection/folders/${folderId}`);
    }
    /**
     * Retrieve metadata about a folder in authenticated user’s collection.
     *
     * @category User Folder
     *
     * @link https://www.discogs.com/developers#page:user-collection,header:user-collection-collection-folder
     */
    async getFolder(folderId) {
        const username = await this.getUsername();
        return this.getFolderForUser(username, folderId);
    }
    /**
     * Edit a folder’s metadata.
     *
     * @remarks
     * Folders 0 and 1 cannot be renamed.
     *
     * @category User Folder
     *
     * @link https://www.discogs.com/developers#page:user-collection,header:user-collection-collection-folder
     */
    async editFolder(folderId, name) {
        const username = await this.getUsername();
        return this.fetch(`/users/${username}/collection/folders/${folderId}`, {}, HTTPVerbsEnum.POST, {
            name,
        });
    }
    /**
     * Delete a folder from a user’s collection.
     *
     * @remarks
     * A folder must be empty before it can be deleted.
     *
     * @category User Folder
     *
     * @link https://www.discogs.com/developers#page:user-collection,header:user-collection-collection-folder
     */
    async deleteFolder(folderId) {
        const username = await this.getUsername();
        return this.fetch(`/users/${username}/collection/folders/${folderId}`, {}, HTTPVerbsEnum.DELETE);
    }
    /**
     * View the user’s collection folders which contain a specified release. This will also show information about each release instance.
     *
     * @remarks
     * Authentication as the collection owner is required if the owner’s collection is private.
     *
     * @category User
     * @label Items By Release
     *
     * @link https://www.discogs.com/developers#page:user-collection,header:user-collection-collection-items-by-release
     */
    async listItemsByReleaseForUser(username, release_id, pagination) {
        return this.fetch(`/users/${username}/collection/releases/${release_id}`, paginate(pagination));
    }
    /**
     * View authenticated user’s collection folders which contain a specified release. This will also show information about each release instance.
     *
     * @category User
     * @label Items By Release
     *
     * @link https://www.discogs.com/developers#page:user-collection,header:user-collection-collection-items-by-release
     */
    async listItemsByRelease(release_id, pagination) {
        const username = await this.getUsername();
        return this.listItemsByReleaseForUser(username, release_id, pagination);
    }
    /**
     * Returns the list of item in a folder in a user’s collection.
     *
     * @remarks
     * Basic information about each release is provided, suitable for display in a list. For detailed information, make another API call to fetch the corresponding release.
     * If folder_id is not 0, or the collection has been made private by its owner, authentication as the collection owner is required.
     * If you are not authenticated as the collection owner, only public notes fields will be visible.
     *
     * @category User
     * @label Collection Items By Folder
     *
     * @link https://www.discogs.com/developers#page:user-collection,header:user-collection-collection-items-by-folder
     */
    async listItemsInFolderForUser(username, folderId, sort, pagination) {
        return this.fetch(`/users/${username}/collection/folders/${folderId}/releases`, {
            ...sortBy(exports.UserSortEnum.ADDED, sort),
            ...paginate(pagination),
        });
    }
    /**
     * Returns the list of item in a folder in authenticated user’s collection.
     *
     * @remarks
     * Basic information about each release is provided, suitable for display in a list. For detailed information, make another API call to fetch the corresponding release.
     *
     * @category User
     * @label Collection Items By Folder
     *
     * @link https://www.discogs.com/developers#page:user-collection,header:user-collection-collection-items-by-folder
     */
    async listItemsInFolder(folderId, sort, pagination) {
        const username = await this.getUsername();
        return this.listItemsInFolderForUser(username, folderId, sort, pagination);
    }
    /**
     * Add a release to a folder in authenticated user’s collection.
     *
     * @category User
     * @label Add To Collection Folder
     *
     * @link https://www.discogs.com/developers#page:user-collection,header:user-collection-add-to-collection-folder
     */
    async addReleaseToFolder(releaseId, folderId = exports.FolderIdsEnum.UNCATEGORIZED) {
        const username = await this.getUsername();
        return this.fetch(`/users/${username}/collection/folders/${folderId}/releases/${releaseId}`, {}, HTTPVerbsEnum.POST);
    }
    /**
     * Change the rating on a release.
     *
     * @category User
     * @label Change Rating Of Release
     *
     * @link https://www.discogs.com/developers#page:user-collection,header:user-collection-change-rating-of-release
     */
    async editReleaseInstanceRating(folderId, releaseId, instanceId, rating) {
        const username = await this.getUsername();
        return this.fetch(`/users/${username}/collection/folders/${folderId}/releases/${releaseId}/instances/${instanceId}`, {}, HTTPVerbsEnum.POST, { rating });
    }
    /**
     * Move the instance of a release to another folder.
     *
     * @category User
     * @label Change Rating Of Release
     *
     * @link https://www.discogs.com/developers#page:user-collection,header:user-collection-change-rating-of-release
     */
    async moveReleaseInstanceToFolder(oldFolderId, releaseId, instanceId, newFolderId) {
        const username = await this.getUsername();
        return this.fetch(`/users/${username}/collection/folders/${oldFolderId}/releases/${releaseId}/instances/${instanceId}`, {}, HTTPVerbsEnum.POST, { folderId: newFolderId });
    }
    /**
     * Remove an instance of a release from authenticated user’s collection folder.
     *
     * @category User
     * @label Delete Instance From Folder
     *
     * @link https://www.discogs.com/developers#page:user-collection,header:user-collection-delete-instance-from-folder
     */
    async deleteReleaseInstanceFromFolder(folderId, releaseId, instanceId) {
        const username = await this.getUsername();
        return this.fetch(`/users/${username}/collection/folders/${folderId}/releases/${releaseId}/instances/${instanceId}`, {}, HTTPVerbsEnum.DELETE);
    }
    /**
     * Retrieve a list of user-defined collection notes fields. These fields are available on every release in the collection.
     *
     * @remarks
     * If the collection has been made private by its owner, authentication as the collection owner is required.
     * If you are not authenticated as the collection owner, only fields with `public` set to true will be visible.
     *
     * @category User
     * @label List Custom Fields
     *
     * @link https://www.discogs.com/developers#page:user-collection,header:user-collection-list-custom-fields
     */
    async listCustomFieldsForUser(username) {
        return this.fetch(`/users/${username}/collection/fields`);
    }
    /**
     * Retrieve a list of authenticated user-defined collection notes fields. These fields are available on every release in the collection.
     *
     * @category User
     * @label List Custom Fields
     *
     * @link https://www.discogs.com/developers#page:user-collection,header:user-collection-list-custom-fields
     */
    async listCustomFields() {
        const username = await this.getUsername();
        return this.listCustomFieldsForUser(username);
    }
    /**
     * Change the value of a notes field on a particular instance.
     *
     * @category User
     * @label Edit Fields Instance
     *
     * @link https://www.discogs.com/developers#page:user-collection,header:user-collection-edit-fields-instance
     */
    async editCustomFieldForInstance(folderId, releaseId, instanceId, fieldId, value) {
        const username = await this.getUsername();
        return this.fetch(`/users/${username}/collection/folders/${folderId}/releases/${releaseId}/instances/${instanceId}/fields/${fieldId}`, { value }, HTTPVerbsEnum.POST);
    }
    /**
     * Returns the minimum, median, and maximum value of authenticated user’s collection.
     *
     * @requires authentication
     *
     * @category User
     * @label Collection Value
     *
     * @link https://www.discogs.com/developers#page:user-collection,header:user-collection-collection-value
     */
    async getCollectionValue() {
        const username = await this.getUsername();
        return this.fetch(`/users/${username}/collection/value`);
    }
    /**
     * Returns the list of releases in a user’s wantlist.
     * Basic information about each release is provided, suitable for display in a list.
     * For detailed information, make another API call to fetch the corresponding release.
     *
     * @remarks
     * If the wantlist has been made private by its owner, you must be authenticated as the owner to view it.
     * The `notes` field will be visible if you are authenticated as the wantlist owner.
     *
     * @category User
     * @label Wantlist
     *
     * @link https://www.discogs.com/developers#page:user-wantlist,header:user-wantlist-wantlist
     */
    async getWantlistForUser(username, pagination) {
        return this.fetch(`/users/${username}/wants`, paginate(pagination));
    }
    /**
     * Returns the list of releases in authenticated user’s wantlist.
     * Basic information about each release is provided, suitable for display in a list.
     * For detailed information, make another API call to fetch the corresponding release.
     *
     * @category User
     * @label Wantlist
     *
     * @link https://www.discogs.com/developers#page:user-wantlist,header:user-wantlist-wantlist
     */
    async getWantlist(pagination) {
        const username = await this.getUsername();
        return this.getWantlistForUser(username, pagination);
    }
    /**
     * Add a release to authenticated user’s wantlist.
     *
     * @category User
     * @label Add to wantlist
     *
     * @link https://www.discogs.com/developers#page:user-wantlist,header:user-wantlist-add-to-wantlist
     */
    async addToWantlist(releaseId, notes, rating) {
        const username = await this.getUsername();
        return this.fetch(`/users/${username}/wants/${releaseId}`, { notes, rating }, HTTPVerbsEnum.PUT);
    }
    /**
     * Remove a release to authenticated user’s wantlist.
     *
     * @category User
     * @label Add to wantlist
     *
     * @link https://www.discogs.com/developers#page:user-wantlist,header:user-wantlist-add-to-wantlist
     */
    async removeFromWantlist(releaseId) {
        const username = await this.getUsername();
        return this.fetch(`/users/${username}/wants/${releaseId}`, {}, HTTPVerbsEnum.DELETE);
    }
    /**
     * Returns user’s lists.
     *
     * @remarks
     * Private lists will only display when authenticated as the owner.
     *
     * @category User
     * @label Lists
     *
     * @link https://www.discogs.com/developers#page:user-lists,header:user-lists-user-lists
     */
    async getListsForUser(username, pagination) {
        return this.fetch(`/users/${username}/lists`, paginate(pagination));
    }
    /**
     * Returns authenticated user’s lists.
     *
     * @category User
     * @label Lists
     *
     * @link https://www.discogs.com/developers#page:user-lists,header:user-lists-user-lists
     */
    async getLists(pagination) {
        const username = await this.getUsername();
        return this.getListsForUser(username, pagination);
    }
    /**
     * Returns items from a specified list.
     *
     * @remarks
     * Private lists will only display when authenticated as the owner.
     *
     * @category User
     * @label Lists
     *
     * @link https://www.discogs.com/developers#page:user-lists,header:user-lists-user-lists
     */
    async getListItems(listId) {
        return this.fetch(`/lists/${listId}`);
    }
    /**
     * Issue a search query to Discogs database.
     *
     * @category Database
     * @label Search
     *
     * @link https://www.discogs.com/developers#page:database,header:database-search
     */
    async searchDatabase(options = {}, pagination) {
        return this.fetch('/database/search', { ...options, ...paginate(pagination) });
    }
    /**
     * Search for a release.
     *
     * @category Database
     * @label Search
     *
     * @link https://www.discogs.com/developers#page:database,header:database-search
     */
    async searchRelease(query, options = {}, pagination) {
        return this.searchDatabase({ ...options, query, type: exports.SearchTypeEnum.RELEASE }, pagination);
    }
    /**
     * Get a release.
     *
     * @category Database
     * @label Release
     *
     * @link https://www.discogs.com/developers#page:database,header:database-release
     */
    async getRelease(releaseId, currency) {
        return this.fetch(`/releases/${releaseId}`, { currency });
    }
    /**
     * Retrieves the release’s rating for a given user.
     *
     * @category Database
     * @label Release Rating
     *
     * @link https://www.discogs.com/developers#page:database,header:database-release-rating-by-user
     */
    async getReleaseRatingForUser(username, releaseId) {
        return this.fetch(`/releases/${releaseId}/rating/${username}`);
    }
    /**
     * Retrieves the release’s rating for the authenticated user.
     *
     * @category Database
     * @label Release Rating
     *
     * @link https://www.discogs.com/developers#page:database,header:database-release-rating-by-user
     */
    async getReleaseRating(releaseId) {
        const username = await this.getUsername();
        return this.getReleaseRatingForUser(username, releaseId);
    }
    /**
     * Updates the release’s rating for the authenticated user.
     *
     * @category Database
     * @label Release Rating
     *
     * @link https://www.discogs.com/developers#page:database,header:database-release-rating-by-user
     */
    async updateReleaseRating(releaseId, rating) {
        const username = await this.getUsername();
        return this.fetch(`/releases/${releaseId}/rating/${username}`, {}, HTTPVerbsEnum.PUT, {
            rating,
        });
    }
    /**
     * Deletes the release’s rating for the authenticated user.
     *
     * @category Database
     * @label Release Rating
     *
     * @link https://www.discogs.com/developers#page:database,header:database-release-rating-by-user
     */
    async deleteReleaseRating(releaseId) {
        const username = await this.getUsername();
        return this.fetch(`/releases/${releaseId}/rating/${username}`, {}, HTTPVerbsEnum.DELETE);
    }
    /**
     * Retrieves the community release rating average and count.
     *
     * @category Database
     * @label Community Release Rating
     *
     * @link https://www.discogs.com/developers#page:database,header:database-community-release-rating
     */
    async getCommunityReleaseRating(releaseId) {
        return this.fetch(`/releases/${releaseId}/rating`);
    }
    /**
     * Search for a master release.
     *
     * @category Database
     * @label Search
     *
     * @link https://www.discogs.com/developers#page:database,header:database-search
     */
    async searchMaster(query, options = {}, pagination) {
        return this.searchDatabase({ ...options, query, type: exports.SearchTypeEnum.MASTER }, pagination);
    }
    /**
     * Get a master release.
     *
     * @category Database
     * @label Master Release
     *
     * @link https://www.discogs.com/developers#page:database,header:database-master-release
     */
    async getMaster(masterId) {
        return this.fetch(`/masters/${masterId}`);
    }
    /**
     * Retrieves a list of all releases that are versions of a master.
     *
     * @category Database
     * @label Master Release Versions
     *
     * @link https://www.discogs.com/developers#page:database,header:database-master-release-versions
     */
    // @TODO: There are a lot of parameters not handled here
    async getMasterVersions(masterId, pagination) {
        return this.fetch(`/masters/${masterId}/versions`, paginate(pagination));
    }
    /**
     * Search for an artist.
     *
     * @category Database
     * @label Search
     *
     * @link https://www.discogs.com/developers#page:database,header:database-search
     */
    async searchArtist(query, options = {}, pagination) {
        return this.searchDatabase({ ...options, query, type: exports.SearchTypeEnum.ARTIST }, pagination);
    }
    /**
     * Get an artist.
     *
     * @category Database
     * @label Artist
     *
     * @link https://www.discogs.com/developers#page:database,header:database-artist
     */
    async getArtist(artistId) {
        return this.fetch(`/artists/${artistId}`);
    }
    /**
     * Returns a list of releases and masters associated with an artist.
     *
     * @category Database
     * @label Artist Releases
     *
     * @link https://www.discogs.com/developers#page:database,header:database-artist-releases
     */
    async getArtistReleases(artistId, sort, pagination) {
        return this.fetch(`/artists/${artistId}/releases`, {
            ...sortBy(exports.ReleaseSortEnum.YEAR, sort),
            ...paginate(pagination),
        });
    }
    /**
     * Search for a label.
     *
     * @category Database
     * @label Search
     *
     * @link https://www.discogs.com/developers#page:database,header:database-search
     */
    async searchLabel(query, options = {}, pagination) {
        return this.searchDatabase({ ...options, query, type: exports.SearchTypeEnum.LABEL }, pagination);
    }
    /**
     * Get a label.
     *
     * @category Database
     * @label Label
     *
     * @link https://www.discogs.com/developers#page:database,header:database-label
     */
    async getLabel(labelId) {
        return this.fetch(`/labels/${labelId}`);
    }
    /**
     * Returns a list of releases associated with the label.
     *
     * @category Database
     * @label Label Releases
     *
     * @link https://www.discogs.com/developers#page:database,header:database-all-label-releases
     */
    async getLabelReleases(labelId, pagination) {
        return this.fetch(`/labels/${labelId}/releases`, paginate(pagination));
    }
    /**
     * Get a seller’s inventory.
     *
     * @remarks
     * If you are not authenticated as the inventory owner, only items that have a status of For Sale will be visible.
     * If you are authenticated as the inventory owner you will get additional weight, format_quantity, external_id, and location keys.
     * If the user is authorized, the listing will contain a `in_cart` boolean field indicating whether or not this listing is in their cart.
     *
     * @category Marketplace
     * @label Inventory
     *
     * @link https://www.discogs.com/developers#page:marketplace,header:marketplace-inventory
     */
    async getInventoryForUser(username, status = exports.InventoryStatusesEnum.ALL, sort, pagination) {
        return this.fetch(`/users/${username}/inventory`, {
            status,
            ...sortBy(exports.InventorySortEnum.LISTED, sort),
            ...paginate(pagination),
        });
    }
    /**
     * Get authenticated user’s inventory.
     *
     * @category Marketplace
     * @label Inventory
     *
     * @link https://www.discogs.com/developers#page:marketplace,header:marketplace-inventory
     */
    async getInventory(status, sort, pagination) {
        const username = await this.getUsername();
        return this.getInventoryForUser(username, status, sort, pagination);
    }
    /**
     * View the data associated with a listing.
     *
     * @remarks
     * If the authorized user is the listing owner the listing will include the weight, format_quantity, external_id, and location keys.
     * If the user is authorized, the listing will contain a in_cart boolean field indicating whether or not this listing is in their cart.
     *
     * @category Marketplace
     * @label Listing
     *
     * @link https://www.discogs.com/developers#page:marketplace,header:marketplace-listing
     */
    async getListing(listingId, currency) {
        return this.fetch(`/marketplace/listings/${listingId}`, { currency });
    }
    /**
     * Edit the data associated with a listing.
     *
     * @remarks
     * If the listing’s status is not For Sale, Draft, or Expired, it cannot be modified – only deleted.
     *
     * @category Marketplace
     * @label Listing
     *
     * @link https://www.discogs.com/developers#page:marketplace,header:marketplace-listing
     */
    async editListing(listingId, options, currency) {
        return this.fetch(`/marketplace/listings/${listingId}`, { currency }, HTTPVerbsEnum.POST, options);
    }
    /**
     * Permanently remove a listing from the Marketplace.
     *
     * @category Marketplace
     * @label Listing
     *
     * @link https://www.discogs.com/developers#page:marketplace,header:marketplace-listing
     */
    async deleteListing(listingId) {
        return this.fetch(`/marketplace/listings/${listingId}`, {}, HTTPVerbsEnum.DELETE);
    }
    /**
     * Create a Marketplace listing.
     *
     * @category Marketplace
     * @label Listing
     *
     * @link https://www.discogs.com/developers#page:marketplace,header:marketplace-new-listing
     */
    async createListing(options) {
        return this.fetch('/marketplace/listings/', {}, HTTPVerbsEnum.POST, options);
    }
    /**
     * View the data associated with an order.
     *
     * @category Marketplace
     * @label Order
     *
     * @link https://www.discogs.com/developers#page:marketplace,header:marketplace-order
     */
    async getOrder(orderId) {
        return this.fetch(`/marketplace/orders/${orderId}`);
    }
    /**
     * Edit the data associated with an order.
     *
     * @category Marketplace
     * @label Order
     *
     * @link https://www.discogs.com/developers#page:marketplace,header:marketplace-order
     */
    async editOrder(orderId, status, shipping) {
        return this.fetch(`/marketplace/orders/${orderId}`, {}, HTTPVerbsEnum.POST, { status, shipping });
    }
    /**
     * Returns a list of the authenticated user’s orders.
     *
     * @category Marketplace
     * @label Order
     *
     * @link https://www.discogs.com/developers#page:marketplace,header:marketplace-list-orders
     */
    async listOrders(status, archived, sort, pagination) {
        return this.fetch('/marketplace/orders', {
            status,
            archived,
            ...sortBy(exports.OrderSortEnum.ID, sort),
            ...paginate(pagination),
        });
    }
    /**
     * Returns a list of the order’s messages with the most recent first.
     *
     * @category Marketplace
     * @label Order Messages
     *
     * @link https://www.discogs.com/developers#page:marketplace,header:marketplace-list-order-messages
     */
    async listOrderMessages(orderId) {
        return this.fetch(`/marketplace/orders/${orderId}/messages`);
    }
    /**
     * Adds a new message to the order’s message log.
     *
     * @remarks
     * When posting a new message, you can simultaneously change the order status.
     * If you do, the message will automatically be prepended with: "Seller changed status from `Old Status` to `New Status`"
     * While message and status are each optional, one or both must be present.
     *
     * @category Marketplace
     * @label Order Messages
     *
     * @link https://www.discogs.com/developers#page:marketplace,header:marketplace-list-order-messages
     */
    async sendOrderMessage(orderId, message, status) {
        return this.fetch(`/marketplace/orders/${orderId}/messages`, {}, HTTPVerbsEnum.POST, {
            message,
            status,
        });
    }
    /**
     * The Fee resource allows you to quickly calculate the fee for selling an item on the Marketplace.
     *
     * @category Marketplace
     * @label Fee
     *
     * @link https://www.discogs.com/developers#page:marketplace,header:marketplace-fee
     */
    async getFee(price, currency) {
        let uri = `/marketplace/fee/${price}`;
        if (currency)
            uri += `/${currency}`;
        return this.fetch(uri);
    }
    /**
     * Retrieve price suggestions for the provided Release ID.
     *
     * @remarks
     * Suggested prices will be denominated in the user’s selling currency.
     *
     * @category Marketplace
     * @label Price Suggestions
     *
     * @link https://www.discogs.com/developers#page:marketplace,header:marketplace-price-suggestions
     */
    async getPriceSuggestions(releaseId) {
        return this.fetch(`/marketplace/price_suggestions/${releaseId}`);
    }
    /**
     * Retrieve marketplace statistics for the provided Release ID.
     *
     * @remarks
     * These statistics reflect the state of the release in the marketplace currently, and include the number of items currently for sale,
     * lowest listed price of any item for sale, and whether the item is blocked for sale in the marketplace.
     *
     *
     * @category Marketplace
     * @label Release Statistics
     *
     * @link https://www.discogs.com/developers#page:marketplace,header:marketplace-release-statistics
     */
    async getMarketplaceStatistics(releaseId, currency) {
        return this.fetch(`/marketplace/stats/${releaseId}`, { currency });
    }
    /**
     * Retrieve an image retrieved in another response.
     *
     * @requires authentication
     *
     * @category Helpers
     *
     * @link https://www.discogs.com/developers#page:images
     */
    async fetchImage(imageUrl) {
        return this.fetch(imageUrl);
    }
}

exports.AuthError = AuthError;
exports.DiscogsError = DiscogsError;
exports.Discojs = Discojs;
